name: Claude Auto Review

on:
  pull_request:
    types: [opened]
    branches: [master]
  issue_comment:
    types: [created]

jobs:
  review:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    if: |
      github.event_name == 'pull_request'
      || (
        github.event_name == 'issue_comment'
        && github.event.issue.pull_request
        && contains(github.event.comment.body, '@claude review')
      )
    permissions:
      contents: read
      pull-requests: write
      issues: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Claude Review
        uses: WalletConnect/actions/claude/auto-review@master
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          project_context: |
            # WalletConnect/Reown GitHub Actions Repository

            ## Repository Purpose & Architecture
            This is a centralized library of reusable GitHub Actions and workflows for the WalletConnect/Reown organization. The repository provides standardized automation for infrastructure deployment, container orchestration, code quality enforcement, and release management across multiple projects in the organization.

            ## Technology Stack & Frameworks
            - **GitHub Actions Composite Actions**: All actions use the `composite` pattern, combining multiple run steps into reusable units
            - **Terraform**: Infrastructure as Code (IaC) for multi-cloud deployments (AWS, Cloudflare, OnePassword, Terraform Cloud)
            - **AWS Services**: ECS (container orchestration), Grafana (monitoring), IAM (authentication)
            - **Shell Scripting**: Bash scripts for orchestration, credential management, and AWS CLI operations
            - **YAML**: Action definitions and workflow configurations
            - **Python**: Optional support for Terraform configurations requiring Python providers
            - **Rust**: Cargo-based release management with semantic versioning
            - **Git Tools**: cocogitto for conventional commits and semantic versioning

            ## Key Architectural Patterns

            ### 1. Composite Action Pattern
            All actions follow the composite pattern with these conventions:
            - Actions are defined in `action.yml` files
            - Use `runs.using: "composite"` declaration
            - Steps use `shell: bash` for script execution
            - Inputs are strongly typed with descriptions and required flags
            - Outputs use `$GITHUB_OUTPUT` for setting values (modern syntax, not deprecated `::set-output`)

            ### 2. Layered Action Architecture
            The repository uses a two-tier architecture:
            - **High-level actions** (`actions/` directory): User-facing composite actions that orchestrate multiple lower-level actions (e.g., `actions/deploy-terraform/`, `actions/plan-terraform/`, `actions/deploy-ecs/`)
            - **Low-level actions** (domain directories): Building blocks used by high-level actions (e.g., `terraform/init/`, `terraform/apply/`, `aws/ecs/deploy-image/`)

            ### 3. Credential Management Pattern
            - **Temporary credentials**: Grafana API keys created on-demand with short TTL (300-900 seconds)
            - **Cleanup guarantee**: Cleanup steps use `if: always()` to ensure credential deletion
            - **Secret masking**: Sensitive values masked with `echo "::add-mask::$value"`
            - **Environment-based injection**: Credentials injected into `.auto.tfvars` files at runtime

            ### 4. Environment Isolation Pattern
            - **Workspace-based**: Terraform workspaces map to environments (dev, staging, prod)
            - **Variable files**: Environment-specific `.tfvars` files in `vars/` directory
            - **Tag-based discovery**: AWS resources discovered via tags (e.g., `Env` tag for Grafana workspaces)

            ## Critical Coding Conventions

            ### YAML Formatting
            - **Indentation**: 2 spaces (enforced by `.editorconfig`)
            - **Line length**: Maximum 80 characters
            - **Line endings**: LF (Unix-style)
            - **Trailing whitespace**: Not allowed
            - **Final newline**: Required in all files

            ### Input/Output Conventions
            - **Input naming**: kebab-case (e.g., `aws-access-key-id`, `task-definition-name`)
            - **Output naming**: kebab-case (e.g., `plan-file`, `output-file`)
            - **Boolean defaults**: Use string `'true'` or `'false'`, not bare booleans
            - **Default values**: Always provide defaults for optional inputs
            - **Backward compatibility**: Mark inputs as `required: false` with defaults when adding new features

            ### Shell Script Conventions
            - **Error handling**: Use `set -e` implicitly (GitHub Actions default)
            - **Variable quoting**: Always quote variables: `"$VARIABLE"`
            - **Conditional checks**: Use `[[ ]]` for bash conditionals
            - **Output capture**: Use `$(command)` for command substitution
            - **JSON parsing**: Use `jq` for JSON manipulation
            - **Array handling**: Use bash arrays for parsing (e.g., `PARTS=($(echo $VAR | tr '\/' "\n"))`)

            ### Terraform-Specific Conventions
            - **Working directory**: Use `working-directory` in steps, not `cd` commands
            - **No color output**: Always use `-no-color` flag for CI/CD compatibility
            - **Auto-approve**: Use `-auto-approve` for apply operations in CI/CD
            - **Variable files**: Check for existence before using: `if [ -f "$VAR_FILE" ]; then`
            - **Workspace selection**: Set via `TF_WORKSPACE` environment variable
            - **Non-interactive**: Set `TF_INPUT=0` to prevent interactive prompts

            ### AWS-Specific Conventions
            - **Credential configuration**: Use `aws-actions/configure-aws-credentials@v4`
            - **Session tokens**: Support optional session tokens for temporary credentials
            - **Region specification**: Always require explicit region specification
            - **Service discovery**: Use AWS CLI with `jq` for resource discovery
            - **ARN parsing**: Parse ARNs by splitting on `/` delimiter

            ## Security Considerations

            ### Credential Security
            - **Never commit secrets**: Pre-commit hooks detect AWS credentials and private keys
            - **Short-lived credentials**: Grafana keys have 5-15 minute TTL
            - **Automatic cleanup**: Credentials deleted in `always()` steps
            - **Secret masking**: All sensitive values masked in logs
            - **No hardcoded values**: All secrets passed via GitHub Secrets

            ### Access Control
            - **Least privilege**: Actions request minimal required permissions
            - **Environment-based**: Credentials scoped to specific environments
            - **Tag-based filtering**: Resources filtered by environment tags
            - **Bot allowlisting**: CTA assistant has explicit bot allowlist

            ### Pre-commit Validation
            The repository enforces these security checks:
            - `detect-aws-credentials`: Prevents AWS credential commits
            - `detect-private-key`: Prevents private key commits
            - `check-merge-conflict`: Prevents merge conflict markers
            - `no-commit-to-branch`: Prevents direct commits to protected branches

            ## Domain-Specific Knowledge

            ### Infrastructure Deployment (Terraform)
            - **Multi-provider support**: AWS, Cloudflare, OnePassword, Terraform Cloud
            - **Provider credentials**: Injected via environment variables (e.g., `CLOUDFLARE_API_TOKEN`, `OP_CONNECT_TOKEN`)
            - **SSH key support**: Private Terraform modules accessed via SSH keys using `webfactory/ssh-agent`
            - **Python support**: Optional Python environment for Terraform providers requiring Python
            - **Plan artifacts**: Binary plan files (`.tfplan`) and human-readable text files generated

            ### Container Deployment (ECS)
            - **Zero-downtime deployments**: `wait-for-service-stability: true` ensures stable deployments
            - **Task definition pattern**: Download current → update image → deploy new revision
            - **Service name resolution**: Extract service name from ARN by parsing
            - **Container naming**: Container name matches task definition name

            ### Release Management
            - **Conventional commits**: Use cocogitto for semantic versioning
            - **Rust releases**: Update `Cargo.toml` and `Cargo.lock` with version bumps
            - **Changelog generation**: Automated via `cog changelog` command
            - **GitHub releases**: Automated release creation with changelog
            - **Version format**: Support both `v1.2.3` and `1.2.3` formats (clean version output)

            ### Code Quality & Review
            - **AI-powered reviews**: Claude AI for intelligent code analysis
            - **Incremental reviews**: Track previous feedback to avoid repetition
            - **Custom validations**: External domain detection, cache-control verification
            - **CTA enforcement**: Copyright Transfer Agreement via PR comments
            - **Allowlist management**: Static allowlist of WalletConnect team members

            ## Performance Considerations
            - **Caching**: Rust actions use `Swatinem/rust-cache@v2` for cargo registry caching
            - **Conditional execution**: Use `if` conditions to skip unnecessary steps
            - **Path filtering**: `paths-filter` action for intelligent CI optimization
            - **Parallel execution**: Actions designed to run independently when possible

            ## Testing Approaches
            - **Pre-commit hooks**: Local validation before commits
            - **YAML validation**: Automated YAML syntax checking
            - **Format checking**: Terraform format validation (`terraform fmt -check`)
            - **Merge conflict detection**: Automated conflict detection

            ## Common Patterns to Follow

            ### When Adding New Actions
            1. Create `action.yml` in appropriate directory (high-level in `actions/`, low-level in domain directories)
            2. Use composite action pattern with `runs.using: "composite"`
            3. Define all inputs with descriptions, required flags, and defaults
            4. Use kebab-case for input/output names
            5. Add `shell: bash` to all script steps
            6. Use `$GITHUB_OUTPUT` for outputs (not deprecated `::set-output`)
            7. Follow 2-space indentation and 80-character line length
            8. Add cleanup steps with `if: always()` for resources
            9. Mask sensitive values with `echo "::add-mask::$value"`
            10. Document the action in a README.md file

            ### When Modifying Existing Actions
            1. Maintain backward compatibility (don't break existing consumers)
            2. Add new inputs as optional with defaults
            3. Deprecate old inputs gracefully (accept but warn)
            4. Update documentation to reflect changes
            5. Test with existing workflows before merging

            ### When Working with Credentials
            1. Always use GitHub Secrets for sensitive values
            2. Create temporary credentials when possible
            3. Set short TTLs (5-15 minutes)
            4. Always clean up in `always()` steps
            5. Mask all sensitive values in logs
            6. Never hardcode credentials in YAML files

            ## Review Focus Areas for This Repository
            - **Security**: Credential handling, secret masking, cleanup steps
            - **Backward compatibility**: Ensure changes don't break existing consumers
            - **Error handling**: Proper error messages and exit codes
            - **Documentation**: Clear descriptions for inputs/outputs
            - **Idempotency**: Actions should be safe to run multiple times
            - **Resource cleanup**: Ensure temporary resources are always cleaned up
            - **Shell script safety**: Proper quoting, error handling, and validation
            - **YAML formatting**: Adherence to `.editorconfig` standards
            - **Conventional commits**: PR titles should follow conventional commit format
