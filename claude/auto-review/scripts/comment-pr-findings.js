#!/usr/bin/env node

/**
 * Comment on PRs with inline findings generated by the Claude auto-review action.
 *
 * Behaviour is intentionally aligned with anthropics/claude-code-security-review/scripts/comment-pr-findings.js
 * so that any upstream improvements can be ported with minimal friction.
 */

const fs = require("fs");
const path = require("path");
const { spawnSync } = require("child_process");

// ---- Utility helpers -----------------------------------------------------

function readJsonFile(filePath) {
  try {
    const data = fs.readFileSync(filePath, "utf8");
    return JSON.parse(data);
  } catch (error) {
    if (error.code === "ENOENT") {
      console.log(
        `Findings file not found at ${filePath}, skipping PR commenting.`
      );
      return null;
    }
    console.error(
      `Failed to read findings file at ${filePath}: ${error.message}`
    );
    throw error;
  }
}

function loadGitHubContext() {
  const repository = process.env.GITHUB_REPOSITORY || "";
  const [owner = "", repo = ""] = repository.split("/");

  let payload = {};
  const eventPath = process.env.GITHUB_EVENT_PATH;
  if (eventPath && fs.existsSync(eventPath)) {
    try {
      payload = JSON.parse(fs.readFileSync(eventPath, "utf8"));
    } catch (error) {
      console.error(`Unable to parse GitHub event payload: ${error.message}`);
      throw error;
    }
  }

  // Handle both pull_request events and issue_comment events on PRs
  let pullRequest = payload.pull_request || {};
  let issueNumber = pullRequest.number || 0;

  // For issue_comment events, check if the issue is a PR
  if (!issueNumber && payload.issue) {
    // issue_comment events have issue.pull_request if the issue is a PR
    if (payload.issue.pull_request) {
      issueNumber = payload.issue.number;
      pullRequest = payload.issue;
    }
  }

  const issue = {
    number: issueNumber,
  };

  return {
    repo: { owner, repo },
    issue,
    payload,
  };
}

function ghApi(endpoint, method = "GET", data = null) {
  const args = ["api", endpoint, "--method", method];

  if (data) {
    args.push("--input", "-");
  }

  const result = spawnSync("gh", args, {
    encoding: "utf8",
    input: data ? JSON.stringify(data) : undefined,
    stdio: ["pipe", "pipe", "pipe"],
  });

  if (result.error) {
    throw new Error(`Failed to invoke gh CLI: ${result.error.message}`);
  }

  if (result.status !== 0) {
    const stderr = result.stderr?.trim();
    throw new Error(
      `gh CLI exited with code ${result.status}${stderr ? `: ${stderr}` : ""}`
    );
  }

  const output = result.stdout?.trim();
  if (!output) return null;

  try {
    return JSON.parse(output);
  } catch (parseError) {
    throw new Error(`Failed to parse gh CLI response: ${parseError.message}`);
  }
}

function generateFindingHash(file, description) {
  const crypto = require("crypto");
  // Use file + description (not line) to handle code shifts
  const content = `${file}::${description}`;
  return crypto
    .createHash("sha256")
    .update(content)
    .digest("hex")
    .substring(0, 16);
}

// ---- Main execution ------------------------------------------------------

function main() {
  const silence = process.env.SILENCE_AUTO_REVIEW_COMMENTS === "true";
  if (silence) {
    console.log(
      "Auto-review comments silenced via SILENCE_AUTO_REVIEW_COMMENTS=true."
    );
    return;
  }

  const findingsPath = path.resolve(
    process.cwd(),
    process.env.FINDINGS_FILE || "findings.json"
  );
  const findings = readJsonFile(findingsPath);

  if (!findings || findings.length === 0) {
    console.log("No findings to report, exiting without commenting.");
    return;
  }

  const context = loadGitHubContext();
  if (!context.issue.number) {
    console.log(
      "GitHub event is not a pull request, skipping PR commenting step."
    );
    return;
  }

  const repoFiles =
    ghApi(
      `/repos/${context.repo.owner}/${context.repo.repo}/pulls/${context.issue.number}/files?per_page=100`
    ) || [];
  const fileMap = repoFiles.reduce((acc, file) => {
    acc[file.filename] = file;
    return acc;
  }, {});

  const reviewComments = [];

  for (const finding of findings) {
    const file = finding.file || finding.path;
    const line = finding.line || (finding.start && finding.start.line) || 1;
    if (!file || !fileMap[file]) {
      console.log(
        `Finding references file ${file} which is not present in PR diff; skipping.`
      );
      continue;
    }

    const message =
      finding.description ||
      (finding.extra && finding.extra.message) ||
      "Issue detected by Claude Auto Review";
    const severity = finding.severity || "MEDIUM";
    const category = finding.category || "code_issue";

    // Generate hash for duplicate detection
    const findingHash = generateFindingHash(file, message);

    let body = `<!-- finding-id: ${findingHash} -->\n`;
    body += `ðŸ¤– **Auto Review Issue: ${message}**\n\n`;
    body += `**Severity:** ${severity}\n`;
    body += `**Category:** ${category}\n`;
    body += `**Tool:** Claude Auto Review\n`;

    const exploit =
      finding.exploit_scenario ||
      (finding.extra &&
        finding.extra.metadata &&
        finding.extra.metadata.exploit_scenario);
    if (exploit) {
      body += `\n**Exploit Scenario:** ${exploit}\n`;
    }

    const recommendation =
      finding.recommendation ||
      (finding.extra &&
        finding.extra.metadata &&
        finding.extra.metadata.recommendation);
    if (recommendation) {
      body += `\n**Recommendation:** ${recommendation}\n`;
    }

    reviewComments.push({
      path: file,
      line,
      side: "RIGHT",
      body,
    });
  }

  if (reviewComments.length === 0) {
    console.log(
      "No valid findings to comment on (filtered out-of-diff items)."
    );
    return;
  }

  const existingComments =
    ghApi(
      `/repos/${context.repo.owner}/${context.repo.repo}/pulls/${context.issue.number}/comments`
    ) || [];

  // Extract finding IDs from existing bot comments
  const existingFindingIds = new Set();
  existingComments.forEach((comment) => {
    if (comment.user?.type === "Bot" && comment.body) {
      const match = comment.body.match(/<!-- finding-id: ([a-f0-9]+) -->/);
      if (match) {
        existingFindingIds.add(match[1]);
      }
    }
  });

  console.log(
    `Found ${existingFindingIds.size} existing auto-review findings on this PR.`
  );

  // Filter out findings that already have comments
  const newReviewComments = reviewComments.filter((comment) => {
    const match = comment.body.match(/<!-- finding-id: ([a-f0-9]+) -->/);
    if (match && existingFindingIds.has(match[1])) {
      console.log(`Skipping duplicate finding: ${match[1]}`);
      return false;
    }
    return true;
  });

  if (newReviewComments.length === 0) {
    console.log("No new findings to comment on (all are duplicates).");
    return;
  }

  console.log(
    `Posting ${newReviewComments.length} new findings (${
      reviewComments.length - newReviewComments.length
    } duplicates skipped).`
  );

  try {
    const reviewResponse = ghApi(
      `/repos/${context.repo.owner}/${context.repo.repo}/pulls/${context.issue.number}/reviews`,
      "POST",
      {
        commit_id: context.payload.pull_request?.head?.sha,
        event: "COMMENT",
        comments: newReviewComments,
      }
    );

    if (reviewResponse?.id) {
      console.log(
        `Created review with ${newReviewComments.length} inline comments.`
      );
    }
  } catch (error) {
    console.error(
      `Failed to create review with inline comments: ${error.message}`
    );
    console.log("Attempting fallback to create individual review comments...");

    for (const comment of newReviewComments) {
      try {
        const response = ghApi(
          `/repos/${context.repo.owner}/${context.repo.repo}/pulls/${context.issue.number}/comments`,
          "POST",
          {
            path: comment.path,
            line: comment.line,
            side: comment.side,
            body: comment.body,
            commit_id: context.payload.pull_request?.head?.sha,
          }
        );
      } catch (fallbackError) {
        console.error(
          `Could not create comment on ${comment.path}:${comment.line}: ${fallbackError.message}`
        );
      }
    }
  }
}

main();
