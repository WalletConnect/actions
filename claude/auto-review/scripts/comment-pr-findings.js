#!/usr/bin/env node

/**
 * Comment on PRs with inline findings generated by the Claude auto-review action.
 *
 * Behaviour is intentionally aligned with anthropics/claude-code-security-review/scripts/comment-pr-findings.js
 * so that any upstream improvements can be ported with minimal friction.
 */

const fs = require("fs");
const path = require("path");
const { spawnSync } = require("child_process");

// ---- Utility helpers -----------------------------------------------------

function readJsonFile(filePath) {
  try {
    const data = fs.readFileSync(filePath, "utf8");
    return JSON.parse(data);
  } catch (error) {
    if (error.code === "ENOENT") {
      console.log(
        `Findings file not found at ${filePath}, skipping PR commenting.`
      );
      return null;
    }
    console.error(
      `Failed to read findings file at ${filePath}: ${error.message}`
    );
    throw error;
  }
}

function loadGitHubContext() {
  const repository = process.env.GITHUB_REPOSITORY || "";
  const [owner = "", repo = ""] = repository.split("/");

  let payload = {};
  const eventPath = process.env.GITHUB_EVENT_PATH;
  if (eventPath && fs.existsSync(eventPath)) {
    try {
      payload = JSON.parse(fs.readFileSync(eventPath, "utf8"));
    } catch (error) {
      console.error(`Unable to parse GitHub event payload: ${error.message}`);
      throw error;
    }
  }

  const pullRequest = payload.pull_request || {};
  const issue = {
    number: pullRequest.number || 0,
  };

  return {
    repo: { owner, repo },
    issue,
    payload,
  };
}

function ghApi(endpoint, method = "GET", data = null) {
  const args = ["api", endpoint, "--method", method];

  if (data) {
    args.push("--input", "-");
  }

  const result = spawnSync("gh", args, {
    encoding: "utf8",
    input: data ? JSON.stringify(data) : undefined,
    stdio: ["pipe", "pipe", "pipe"],
  });

  if (result.error) {
    throw new Error(`Failed to invoke gh CLI: ${result.error.message}`);
  }

  if (result.status !== 0) {
    const stderr = result.stderr?.trim();
    throw new Error(
      `gh CLI exited with code ${result.status}${stderr ? `: ${stderr}` : ""}`
    );
  }

  const output = result.stdout?.trim();
  return output ? JSON.parse(output) : null;
}

function addReactions(commentId, context, isReviewComment = true) {
  const baseEndpoint = isReviewComment
    ? `/repos/${context.repo.owner}/${context.repo.repo}/pulls/comments/${commentId}/reactions`
    : `/repos/${context.repo.owner}/${context.repo.repo}/issues/comments/${commentId}/reactions`;

  for (const reaction of ["+1", "-1"]) {
    try {
      ghApi(baseEndpoint, "POST", { content: reaction });
      console.log(`Added ${reaction} reaction to comment ${commentId}`);
    } catch (error) {
      console.error(
        `Failed to add ${reaction} reaction to comment ${commentId}: ${error.message}`
      );
    }
  }
}

// ---- Main execution ------------------------------------------------------

function main() {
  const silence = process.env.SILENCE_AUTO_REVIEW_COMMENTS === "true";
  if (silence) {
    console.log(
      "Auto-review comments silenced via SILENCE_AUTO_REVIEW_COMMENTS=true."
    );
    return;
  }

  const findingsPath = path.resolve(
    process.cwd(),
    process.env.FINDINGS_FILE || "findings.json"
  );
  const findings = readJsonFile(findingsPath);

  if (!findings || findings.length === 0) {
    console.log("No findings to report, exiting without commenting.");
    return;
  }

  const context = loadGitHubContext();
  if (!context.issue.number) {
    console.log(
      "GitHub event is not a pull request, skipping PR commenting step."
    );
    return;
  }

  const repoFiles =
    ghApi(
      `/repos/${context.repo.owner}/${context.repo.repo}/pulls/${context.issue.number}/files?per_page=100`
    ) || [];
  const fileMap = repoFiles.reduce((acc, file) => {
    acc[file.filename] = file;
    return acc;
  }, {});

  const reviewComments = [];

  for (const finding of findings) {
    const file = finding.file || finding.path;
    const line = finding.line || (finding.start && finding.start.line) || 1;
    if (!file || !fileMap[file]) {
      console.log(
        `Finding references file ${file} which is not present in PR diff; skipping.`
      );
      continue;
    }

    const message =
      finding.description ||
      (finding.extra && finding.extra.message) ||
      "Issue detected by Claude Auto Review";
    const severity = finding.severity || "MEDIUM";
    const category = finding.category || "code_issue";

    let body = `ðŸ¤– **Auto Review Issue: ${message}**\n\n`;
    body += `**Severity:** ${severity}\n`;
    body += `**Category:** ${category}\n`;
    body += `**Tool:** Claude Auto Review\n`;

    const exploit =
      finding.exploit_scenario ||
      (finding.extra &&
        finding.extra.metadata &&
        finding.extra.metadata.exploit_scenario);
    if (exploit) {
      body += `\n**Exploit Scenario:** ${exploit}\n`;
    }

    const recommendation =
      finding.recommendation ||
      (finding.extra &&
        finding.extra.metadata &&
        finding.extra.metadata.recommendation);
    if (recommendation) {
      body += `\n**Recommendation:** ${recommendation}\n`;
    }

    reviewComments.push({
      path: file,
      line,
      side: "RIGHT",
      body,
    });
  }

  if (reviewComments.length === 0) {
    console.log(
      "No valid findings to comment on (filtered out-of-diff items)."
    );
    return;
  }

  const existingComments =
    ghApi(
      `/repos/${context.repo.owner}/${context.repo.repo}/pulls/${context.issue.number}/comments`
    ) || [];
  const existingBotComments = existingComments.filter(
    (comment) =>
      comment.user?.type === "Bot" &&
      typeof comment.body === "string" &&
      comment.body.includes("ðŸ¤– **Auto Review Issue:")
  );

  if (existingBotComments.length > 0) {
    console.log(
      `Detected ${existingBotComments.length} existing auto-review comments. Skipping to avoid duplicates.`
    );
    return;
  }

  try {
    const reviewResponse = ghApi(
      `/repos/${context.repo.owner}/${context.repo.repo}/pulls/${context.issue.number}/reviews`,
      "POST",
      {
        commit_id: context.payload.pull_request?.head?.sha,
        event: "COMMENT",
        comments: reviewComments,
      }
    );

    if (reviewResponse?.id) {
      console.log(
        `Created review with ${reviewComments.length} inline comments.`
      );
      const reviewId = reviewResponse.id;
      const reviewCommentsResponse =
        ghApi(
          `/repos/${context.repo.owner}/${context.repo.repo}/pulls/${context.issue.number}/reviews/${reviewId}/comments`
        ) || [];
      for (const comment of reviewCommentsResponse) {
        if (comment.id) {
          addReactions(comment.id, context, true);
        }
      }
    }
  } catch (error) {
    console.error(
      `Failed to create review with inline comments: ${error.message}`
    );
    console.log("Attempting fallback to create individual review comments...");

    for (const comment of reviewComments) {
      try {
        const response = ghApi(
          `/repos/${context.repo.owner}/${context.repo.repo}/pulls/${context.issue.number}/comments`,
          "POST",
          {
            path: comment.path,
            line: comment.line,
            side: comment.side,
            body: comment.body,
            commit_id: context.payload.pull_request?.head?.sha,
          }
        );

        if (response?.id) {
          addReactions(response.id, context, true);
        }
      } catch (fallbackError) {
        console.error(
          `Could not create comment on ${comment.path}:${comment.line}: ${fallbackError.message}`
        );
      }
    }
  }
}

main();
